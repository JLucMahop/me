<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://alshedivat.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alshedivat.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-11-16T16:19:50+00:00</updated><id>https://alshedivat.github.io/feed.xml</id><title type="html">luc-mahop</title><subtitle>A research scientist in Operating systems, memory management, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Understanding Virtualization and Hypervisors: A Technical Introduction</title><link href="https://alshedivat.github.io/blog/2025/virtualization-and-hypervisors/" rel="alternate" type="text/html" title="Understanding Virtualization and Hypervisors: A Technical Introduction"/><published>2025-10-30T14:00:00+00:00</published><updated>2025-10-30T14:00:00+00:00</updated><id>https://alshedivat.github.io/blog/2025/virtualization-and-hypervisors</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/virtualization-and-hypervisors/"><![CDATA[<p>Virtualization is a foundational concept in <strong>modern computing</strong>, allowing multiple isolated operating systems to share the same physical hardware.<br/> It underpins <strong>cloud computing</strong>, <strong>data center scalability</strong>, and <strong>secure workload isolation</strong>.</p> <p>This post provides a technically rich yet accessible introduction to <strong>virtualization</strong>, its <strong>architecture</strong>, and the <strong>different types of hypervisors</strong>, with clickable academic and industry references.</p> <hr/> <h2 id="1-what-is-virtualization">1. What Is Virtualization?</h2> <p>At its core, <strong>virtualization</strong> is the process of abstracting hardware resources — such as CPU, memory, storage, and network — into <strong>virtual resources</strong> that multiple virtual machines (VMs) can use simultaneously.</p> <p>Each VM behaves as though it has its own hardware, thanks to a layer called the <strong>hypervisor</strong> (or Virtual Machine Monitor, VMM).</p> <p>+——————————————————-+ | Virtual Machines (VMs) | | +———+ +———+ +———+ | | | GuestOS | | GuestOS | | GuestOS | | | +———+ +———+ +———+ | | | Virtual Hardware (vCPU, vRAM, vNIC) | | +——————————————————-+ | Hypervisor (VMM Layer) | +——————————————————-+ | Physical Hardware (Host) | +——————————————————-+</p> <p><strong>In simple terms:</strong> virtualization allows one computer to act like many.</p> <hr/> <h2 id="2-why-virtualization-matters">2. Why Virtualization Matters</h2> <p>Virtualization provides several critical benefits:</p> <ul> <li><strong>Resource Efficiency:</strong> Better hardware utilization and consolidation.</li> <li><strong>Isolation:</strong> Faults in one VM don’t affect others.</li> <li><strong>Flexibility:</strong> Rapid provisioning and scaling.</li> <li><strong>Portability:</strong> Live migration and snapshots for fault tolerance.</li> </ul> <p>These capabilities are fundamental to modern clouds such as <strong>AWS EC2</strong>, <strong>Google Cloud</strong>, and <strong>Microsoft Azure</strong>.</p> <hr/> <h2 id="3-virtualization-architecture">3. Virtualization Architecture</h2> <p>Here’s a conceptual diagram of how virtualization layers interact:</p> <p><img src="https://miro.medium.com/v2/resize:fit:1400/1*7S9p3I4Xn58ZBftu-mk3hw.png" alt="Virtualization Architecture Diagram"/></p> <p><em>Figure 1 — The virtualization stack: physical hardware, hypervisor, and guest operating systems (Image source: <a href="https://medium.com/virtuallygenius">Medium / VirtuallyGenius</a>).</em></p> <p><strong>Layers:</strong></p> <ol> <li><strong>Host Hardware</strong> — The actual CPU, memory, I/O, and storage.</li> <li><strong>Hypervisor</strong> — Software that manages VMs and resource scheduling.</li> <li><strong>Guest OS</strong> — Each VM’s operating system (Linux, Windows, etc.).</li> <li><strong>Applications</strong> — User-level processes within each guest.</li> </ol> <hr/> <h2 id="4-how-virtualization-works">4. How Virtualization Works</h2> <p>When a guest OS executes privileged CPU instructions, the hypervisor intercepts them and safely emulates or forwards them to the hardware using <strong>virtualization extensions</strong>.</p> <table> <thead> <tr> <th>CPU Vendor</th> <th>Virtualization Extension</th> <th>Notable Features</th> </tr> </thead> <tbody> <tr> <td>Intel</td> <td><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">VT-x (VMX)</a></td> <td>Hardware-assisted virtualization, EPT for memory mapping</td> </tr> <tr> <td>AMD</td> <td><a href="https://www.amd.com/en/developer/resources.html">AMD-V (SVM)</a></td> <td>Nested paging, secure encrypted virtualization</td> </tr> <tr> <td>ARM</td> <td><a href="https://developer.arm.com/documentation/den0024/a/">ARM Virtualization Extensions</a></td> <td>Dedicated EL2 privilege level for hypervisors</td> </tr> </tbody> </table> <h3 id="cpu-privilege-rings">CPU Privilege Rings</h3> <p>CPUs traditionally use privilege rings (Ring 0 = kernel, Ring 3 = user space).<br/> Virtualization introduces <strong>Ring -1</strong>, a special privilege mode for hypervisors:</p> <p>Ring -1 – Hypervisor (VMM) Ring 0 – Guest OS Kernel Ring 3 – Guest Applications</p> <p>This ensures hypervisors can manage VMs securely without violating isolation boundaries.</p> <hr/> <h2 id="5-types-of-hypervisors">5. Types of Hypervisors</h2> <p>Hypervisors are categorized into <strong>Type 1 (bare-metal)</strong> and <strong>Type 2 (hosted)</strong> architectures.</p> <hr/> <h3 id="type-1--bare-metal-hypervisors">Type 1 — Bare-Metal Hypervisors</h3> <p>Type 1 hypervisors run <strong>directly on hardware</strong>, managing guest OSes natively without an intermediary host OS.</p> <p><strong>Examples:</strong></p> <ul> <li><a href="https://www.vmware.com/products/esxi-and-esx.html">VMware ESXi</a></li> <li><a href="https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/hyper-v-technology-overview">Microsoft Hyper-V Server</a></li> <li><a href="https://xenproject.org/">Xen Project</a></li> <li><a href="https://www.linux-kvm.org/page/Main_Page">KVM (Kernel-based Virtual Machine)</a></li> </ul> <p><img src="https://miro.medium.com/v2/resize:fit:1400/1*7nD8tVJQj1bYTrJ3kS8gbw.png" alt="Type 1 Hypervisor Diagram"/></p> <p><em>Figure 2 — Type 1 (bare-metal) hypervisor directly managing guest OSes (Image source: <a href="https://medium.com/cloudcomputingsimplified">Medium / CloudComputingSimplified</a>).</em></p> <p><strong>Key Characteristics:</strong></p> <ul> <li>Highest performance and lowest overhead.</li> <li>Preferred for <strong>enterprise</strong>, <strong>data centers</strong>, and <strong>cloud environments</strong>.</li> <li>Direct access to CPU virtualization instructions (VT-x, AMD-V).</li> </ul> <hr/> <h3 id="type-2--hosted-hypervisors">Type 2 — Hosted Hypervisors</h3> <p>Type 2 hypervisors run <strong>on top of a host OS</strong>.<br/> They rely on the host OS for hardware drivers and system management.</p> <p><strong>Examples:</strong></p> <ul> <li><a href="https://www.vmware.com/products/workstation-pro.html">VMware Workstation</a></li> <li><a href="https://www.virtualbox.org/">Oracle VirtualBox</a></li> <li><a href="https://www.parallels.com/">Parallels Desktop</a></li> </ul> <p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Piyj7VxOtO6zI1cPlI2gCw.png" alt="Type 2 Hypervisor Diagram"/></p> <p><em>Figure 3 — Type 2 (hosted) hypervisor architecture (Image source: <a href="https://medium.com/techwithshubham">Medium / TechWithShubham</a>).</em></p> <p><strong>Key Characteristics:</strong></p> <ul> <li>Easier to install and use.</li> <li>Slightly higher overhead due to double scheduling (host + guest).</li> <li>Common for <strong>testing</strong>, <strong>development</strong>, and <strong>education</strong> setups.</li> </ul> <hr/> <h2 id="6-advanced-virtualization-techniques">6. Advanced Virtualization Techniques</h2> <p>Modern hypervisors use several optimization and isolation models:</p> <ul> <li><strong>Paravirtualization:</strong> Guest OS modified to be “hypervisor-aware” (e.g., <a href="https://xenproject.org/learn-more/technical-overview/">Xen PV</a>).</li> <li><strong>Hardware-Assisted Virtualization:</strong> Uses CPU extensions to eliminate trapping overhead.</li> <li><strong>Microkernel Hypervisors:</strong> Minimal trusted code base, e.g. <a href="https://sel4.systems/">seL4</a> and <a href="https://os.inf.tu-dresden.de/fiasco/">Nova</a>.</li> <li><strong>Nested Virtualization:</strong> Running a hypervisor inside another VM — common in research and cloud testbeds.</li> </ul> <hr/> <h2 id="7-virtualization-vs-containers">7. Virtualization vs Containers</h2> <p>Virtualization replicates hardware, while <strong>containers</strong> virtualize the operating system.</p> <table> <thead> <tr> <th>Feature</th> <th>Virtual Machines</th> <th>Containers</th> </tr> </thead> <tbody> <tr> <td>Kernel</td> <td>Separate per VM</td> <td>Shared host kernel</td> </tr> <tr> <td>Isolation</td> <td>Strong (hardware)</td> <td>Moderate (namespaces)</td> </tr> <tr> <td>Startup Time</td> <td>Seconds</td> <td>Milliseconds</td> </tr> <tr> <td>Overhead</td> <td>High</td> <td>Low</td> </tr> <tr> <td>Example Tools</td> <td>VMware, KVM, Xen</td> <td>Docker, Kubernetes</td> </tr> </tbody> </table> <p><img src="https://miro.medium.com/v2/resize:fit:1400/1*pXLULKiZ-5EPqObYlU9y5A.png" alt="VMs vs Containers Diagram"/></p> <p><em>Figure 4 — Virtual machines vs containers (Image source: <a href="https://www.docker.com/blog/containers-and-virtual-machines-differences/">Docker Blog</a>).</em></p> <hr/> <h2 id="8-security-considerations">8. Security Considerations</h2> <p>The <strong>hypervisor</strong> is part of the system’s <strong>Trusted Computing Base (TCB)</strong>, meaning it must be highly secure and minimal.</p> <p>Security mechanisms include:</p> <ul> <li><a href="https://www.intel.com/content/www/us/en/io/direct-io/virtualization-technology-for-directed-io.html">IOMMU</a> — Protects against DMA attacks.</li> <li><a href="https://www.amd.com/en/developer/sev.html">AMD SEV</a> — Encrypts VM memory for confidentiality.</li> <li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html">Intel TDX</a> — Isolates VMs in trusted execution domains.</li> <li><a href="https://uefi.org/specifications">Secure Boot</a> — Ensures only verified hypervisors load at startup.</li> </ul> <hr/> <h2 id="9-summary-table">9. Summary Table</h2> <table> <thead> <tr> <th>Feature</th> <th>Type 1 Hypervisor</th> <th>Type 2 Hypervisor</th> </tr> </thead> <tbody> <tr> <td>Execution Environment</td> <td>Bare metal</td> <td>Host OS</td> </tr> <tr> <td>Performance</td> <td>High</td> <td>Moderate</td> </tr> <tr> <td>Security</td> <td>Strong isolation</td> <td>Depends on host</td> </tr> <tr> <td>Example Use</td> <td>Cloud, servers</td> <td>Desktop, testing</td> </tr> <tr> <td>Examples</td> <td>KVM, Xen, ESXi</td> <td>VirtualBox, Parallels</td> </tr> </tbody> </table> <hr/> <h2 id="references">References</h2> <ol> <li><a href="https://dl.acm.org/doi/10.1145/361011.361073">Popek, G. J., &amp; Goldberg, R. P. (1974). <em>Formal Requirements for Virtualizable Third Generation Architectures.</em> Communications of the ACM, 17(7), 412–421.</a></li> <li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel Corporation. <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual.</em> Volume 3, 2023.</a></li> <li><a href="https://www.amd.com/en/developer/resources.html">AMD. <em>AMD-V™ Architecture Reference Manual.</em>, 2022.</a></li> <li><a href="https://dl.acm.org/doi/10.1145/945445.945462">Barham, P. et al. <em>Xen and the Art of Virtualization.</em> SOSP, 2003.</a></li> <li><a href="https://ieeexplore.ieee.org/document/1435664">Rosenblum, M., &amp; Garfinkel, T. <em>Virtual Machine Monitors: Current Technology and Future Trends.</em> IEEE Computer, 38(5), 2005.</a></li> <li><a href="https://www.linux-kvm.org/page/Main_Page">Kivity, A. <em>KVM: The Linux Virtual Machine Monitor.</em> Ottawa Linux Symposium, 2007.</a></li> <li><a href="https://developer.arm.com/documentation/den0024/a/">ARM Ltd. <em>Virtualization Extensions Architecture Reference Manual.</em>, 2023.</a></li> </ol> <hr/> <p><em>Authored by Luc MAHOP, Ph.D. Student in Computer Science.</em><br/> <em>Published on https://alshedivat.github.io/blog/2025/virtualization-and-hypervisors</em></p>]]></content><author><name></name></author><category term="computer-systems"/><category term="virtualization"/><category term="hypervisor"/><category term="kvm"/><category term="vmware"/><category term="xen"/><category term="cloud"/><category term="computing"/><category term="systems"/><summary type="html"><![CDATA[A beginner-friendly yet technically rigorous introduction to virtualization and hypervisor architectures, with diagrams and references.]]></summary></entry><entry><title type="html">A Technical Comparison of x86 and ARM Architectures</title><link href="https://alshedivat.github.io/blog/2025/x86-vs-arm-architectural-analysis/" rel="alternate" type="text/html" title="A Technical Comparison of x86 and ARM Architectures"/><published>2025-10-30T09:00:00+00:00</published><updated>2025-10-30T09:00:00+00:00</updated><id>https://alshedivat.github.io/blog/2025/x86-vs-arm-architectural-analysis</id><content type="html" xml:base="https://alshedivat.github.io/blog/2025/x86-vs-arm-architectural-analysis/"><![CDATA[<p>The evolution of processor architectures has profoundly influenced computing paradigms across performance, power efficiency, and scalability dimensions. Among contemporary architectures, <strong>x86</strong> (Complex Instruction Set Computing — <em>CISC</em>) and <strong>ARM</strong> (Reduced Instruction Set Computing — <em>RISC</em>) dominate the general-purpose computing landscape.<br/> This post provides a <strong>technical comparative analysis</strong> of these architectures, intended for researchers and engineers in computer systems design.</p> <hr/> <h2 id="1-instruction-set-philosophy">1. Instruction Set Philosophy</h2> <h3 id="x86-cisc-complexity">x86: CISC Complexity</h3> <p>The <strong>x86 ISA</strong>, introduced with the Intel 8086 (1978), implements a <em>complex instruction set</em> containing over 1,500 opcodes in modern extensions (Intel, 2023).<br/> Key characteristics include:</p> <ul> <li><strong>Variable-length instructions</strong> (1–15 bytes), enabling compact encoding at the expense of decoding complexity.</li> <li>Support for <strong>orthogonal addressing modes</strong> and <strong>microcoded execution</strong>.</li> <li>Numerous extensions: SSE, AVX, AVX-512, and transactional memory (TSX).</li> <li><strong>Backward compatibility</strong> guarantees—legacy instructions from the 1980s remain executable.</li> </ul> <p>These features result in deep pipelines and sophisticated instruction decoders, often with <strong>multiple µop fusion stages</strong> to translate CISC instructions into RISC-like micro-operations internally.</p> <h3 id="arm-risc-minimalism">ARM: RISC Minimalism</h3> <p>The <strong>ARM architecture</strong> (Advanced RISC Machines), first commercialized in 1985, emphasizes:</p> <ul> <li><strong>Fixed-length instructions</strong> (mostly 32-bit, or 16-bit in <em>Thumb</em> mode).</li> <li>A <strong>load-store model</strong>, where arithmetic operations act only on registers.</li> <li><strong>Conditional execution</strong> for minimizing branch penalties.</li> <li>Scalable privilege modes and well-defined exception levels (EL0–EL3) in ARMv8–v9.</li> </ul> <p>ARM’s clean instruction set facilitates <em>pipelining and superscalar issue</em>, resulting in higher energy efficiency per instruction at similar process nodes (ARM Holdings, 2022).</p> <hr/> <h2 id="2-microarchitectural-design-comparison">2. Microarchitectural Design Comparison</h2> <table> <thead> <tr> <th>Feature</th> <th>x86 (Intel Core, AMD Zen)</th> <th>ARM (Cortex-A, Apple M-series)</th> </tr> </thead> <tbody> <tr> <td><strong>ISA Type</strong></td> <td>CISC</td> <td>RISC</td> </tr> <tr> <td><strong>Pipeline Depth</strong></td> <td>14–19 stages (Alder Lake)</td> <td>9–11 stages (Cortex-A78)</td> </tr> <tr> <td><strong>Decode Width</strong></td> <td>4–6 µops</td> <td>4–8 instructions</td> </tr> <tr> <td><strong>Branch Prediction</strong></td> <td>TAGE hybrid + indirect predictor</td> <td>Neural + perceptron predictors (Apple M3)</td> </tr> <tr> <td><strong>Execution Model</strong></td> <td>Out-of-order superscalar</td> <td>Out-of-order superscalar</td> </tr> <tr> <td><strong>Cache Hierarchy</strong></td> <td>Inclusive, up to 3 levels + L4 (eDRAM in some Xeons)</td> <td>Exclusive, up to 3 levels</td> </tr> <tr> <td><strong>Security Features</strong></td> <td>Intel SGX, CET, AMD SEV</td> <td>ARM TrustZone, Pointer Authentication (PAC)</td> </tr> <tr> <td><strong>Power Management</strong></td> <td>Speed Shift, Turbo Boost</td> <td>DVFS, big.LITTLE / DynamIQ</td> </tr> </tbody> </table> <p>Modern ARM designs (e.g., Apple M2, AWS Graviton3) rival or exceed x86 performance-per-watt by leveraging wider out-of-order execution, high IPC, and advanced 5 nm fabrication processes.</p> <hr/> <h2 id="3-power-and-thermal-efficiency">3. Power and Thermal Efficiency</h2> <p>Power efficiency, measured as <strong>performance per watt</strong>, remains ARM’s strongest domain.<br/> ARM’s design avoids deep speculation and microcode overhead, achieving high energy proportionality — crucial for mobile and hyperscale workloads.</p> <p>Empirical data (SPECint2017 benchmark; Hennessy &amp; Patterson, 2023) indicates:</p> <table> <thead> <tr> <th>Metric</th> <th>Intel i9-13900K</th> <th>Apple M2 (ARMv8.6-A)</th> </tr> </thead> <tbody> <tr> <td><strong>Peak TDP</strong></td> <td>125 W</td> <td>20 W</td> </tr> <tr> <td><strong>Performance/Watt</strong></td> <td>1×</td> <td>~4.5× higher</td> </tr> <tr> <td><strong>Core Count (P+E)</strong></td> <td>24 (8P + 16E)</td> <td>8 (4P + 4E)</td> </tr> </tbody> </table> <p>This divergence arises from <strong>microarchitectural efficiency</strong> (simpler decode/issue stages) and <strong>fabrication synergy</strong> with SoC integration.</p> <hr/> <h2 id="4-software-ecosystem-and-compatibility">4. Software Ecosystem and Compatibility</h2> <h3 id="x86-ecosystem">x86 Ecosystem</h3> <ul> <li>Mature support across <strong>Windows</strong>, <strong>Linux</strong>, and <strong>BSD</strong>.</li> <li>Robust ecosystem for HPC (x86-64 vectorization libraries: Intel MKL, AMD AOCL).</li> <li>Decades of compiler optimization (GCC, LLVM, ICC).</li> </ul> <h3 id="arm-ecosystem">ARM Ecosystem</h3> <ul> <li>Native in <strong>Android</strong>, <strong>iOS</strong>, and <strong>embedded</strong> systems.</li> <li>Increasing adoption in <strong>HPC</strong>: <em>Fugaku</em> (ARM A64FX, Japan) topped the TOP500 in 2020.</li> <li><strong>Binary translation frameworks</strong> (Rosetta 2, QEMU) mitigate compatibility issues.</li> </ul> <p>ARM’s success in datacenters (AWS Graviton3, Ampere Altra) demonstrates the maturity of <strong>64-bit ARMv8-A</strong> and <strong>v9-A</strong> ecosystems, supported by compilers such as <em>LLVM 17</em> and <em>Arm Compiler for Linux</em>.</p> <hr/> <h2 id="5-hardware-security-and-virtualization">5. Hardware Security and Virtualization</h2> <table> <thead> <tr> <th>Security Feature</th> <th>x86</th> <th>ARM</th> </tr> </thead> <tbody> <tr> <td>Hardware Isolation</td> <td>Intel VT-x, AMD-V</td> <td>ARM Virtualization Extensions</td> </tr> <tr> <td>Trusted Execution</td> <td>Intel SGX, AMD SEV</td> <td>ARM TrustZone</td> </tr> <tr> <td>Memory Tagging</td> <td>CET (Control-flow Enforcement)</td> <td>MTE (Memory Tagging Extension)</td> </tr> <tr> <td>Pointer Authentication</td> <td>N/A</td> <td>PAC (ARMv8.3-A+)</td> </tr> </tbody> </table> <p>ARM’s hardware-level <strong>TrustZone</strong> and <strong>PAC</strong> have made it attractive for <strong>secure IoT</strong> and <strong>mobile</strong> computing, while x86 dominates confidential cloud computing with <strong>SEV-SNP</strong> and <strong>TDX</strong>.</p> <hr/> <h2 id="6-quantitative-benchmarking">6. Quantitative Benchmarking</h2> <p>Representative data from peer-reviewed and industry sources:</p> <ul> <li><strong>Performance/Watt scaling (Perf/W)</strong>: ARMv9 (5 nm) outperforms x86 (Intel 7 nm) by ~4× on SPECint2017 and Geekbench 6 (AnandTech, 2024).</li> <li><strong>Floating-Point throughput</strong>: AVX-512 offers up to 2 TFLOPS/core theoretical peak; ARM NEON/Scalable Vector Extensions (SVE2) achieve comparable efficiency per mm² at lower frequency.</li> <li><strong>Latency sensitivity</strong>: ARM cores show lower L1 miss penalties (~6 cycles) due to shallower pipelines.</li> </ul> <hr/> <h2 id="7-future-directions">7. Future Directions</h2> <ul> <li><strong>x86</strong>: Transitioning to hybrid architectures (P/E cores) for better energy scaling; future emphasis on <em>AI-optimized instructions</em> (Intel APX, AMD XDNA).</li> <li><strong>ARM</strong>: Advancing toward <em>unified compute fabrics</em> (SoC + NPU + GPU) and <em>post-v9 instruction sets</em> with built-in AI accelerators.</li> <li><strong>Open ISA competition</strong>: RISC-V challenges both in academic and low-power domains, emphasizing modular instruction design.</li> </ul> <hr/> <h2 id="8-conclusion">8. Conclusion</h2> <p>The <strong>x86–ARM dichotomy</strong> reflects divergent but converging evolutionary paths:</p> <ul> <li>x86: deep backward compatibility, raw performance, enterprise legacy.</li> <li>ARM: efficiency, scalability, and SoC integration.</li> </ul> <p>In modern workloads, <strong>architecture matters less than microarchitectural innovation and compiler co-design</strong>. The lines between RISC and CISC continue to blur as both adopt hybrid decoding and speculative execution.</p> <hr/> <h2 id="references">References</h2> <ol> <li>Intel Corporation. <em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 1–3.</em> Revision 079, June 2023.</li> <li>ARM Ltd. <em>ARM Architecture Reference Manual ARMv9-A.</em> Version 9.4, Cambridge, UK, 2022.</li> <li>Hennessy, J. L., &amp; Patterson, D. A. <em>Computer Architecture: A Quantitative Approach (7th Ed.).</em> Morgan Kaufmann, 2023.</li> <li>Apple Inc. <em>Apple Silicon Technical Overview.</em> WWDC Developer Documentation, 2023.</li> <li>AMD. <em>Zen 4 Core Microarchitecture White Paper.</em> Advanced Micro Devices, 2022.</li> <li>Fujitsu Ltd. <em>A64FX Microarchitecture and Implementation.</em> IEEE Micro, vol. 41, no. 3, 2021.</li> <li>AnandTech. “The ARM vs x86 Performance-per-Watt Comparison: 2024 Update.” <em>AnandTech Labs</em>, Feb 2024.</li> <li>ARM Research. <em>Energy Efficiency and Scalability in ARMv9 Processors.</em> Technical Report, 2022.</li> </ol> <hr/> <p><em>Authored by Luc MAHOP, Ph.D. Student in Computer Science.</em><br/> <em>Published on https://alshedivat.github.io/blog/2025/x86-vs-arm-architectural-analysis</em></p>]]></content><author><name></name></author><category term="research"/><category term="cpu"/><category term="architecture"/><category term="computer-architecture"/><category term="x86"/><category term="arm"/><category term="risc"/><category term="cisc"/><summary type="html"><![CDATA[A detailed comparative study of x86 and ARM CPU architectures — instruction set design, microarchitecture, power-performance trade-offs, and ecosystem evolution.]]></summary></entry></feed>